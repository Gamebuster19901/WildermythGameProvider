plugins {
	id 'java-library'
	id 'eclipse'
	id 'maven-publish'
}

repositories {
	mavenCentral()
	maven {
		url "https://repo.spongepowered.org/maven/"
	}
	maven {
		url "https://maven.fabricmc.net/"
	}
	mavenLocal()
}

java {
    modularity.inferModulePath.set(true)
}

sourceCompatibility = '17'
targetCompatibility = '17'

version = providerVersion
group = "com.wildermods"
archivesBaseName = "provider"

configurations {
	compileOnlyResolvable {
		extendsFrom compileOnly
	}
	implementationResolvable {
		extendsFrom implementation
	}
}

dependencies {

	compileOnly group: 'net.fabricmc', name: 'fabric-loader', version: fabricVersion

	//mixin requirements:
	compileOnly group: 'net.fabricmc', name: 'sponge-mixin', version: mixinVersion
	
	compileOnly group: 'org.ow2.asm', name: 'asm', version: asmVersion
	compileOnly group: 'org.ow2.asm', name: 'asm-analysis', version: asmVersion
	compileOnly group: 'org.ow2.asm', name: 'asm-commons', version: asmVersion
	compileOnly group: 'org.ow2.asm', name: 'asm-tree', version: asmVersion
	compileOnly group: 'org.ow2.asm', name: 'asm-util', version: asmVersion
	
	implementation group: 'org.apache.commons', name: 'commons-lang3', version: commonsLangVersion

}

tasks.compileJava {
	options.compilerArgs += [
		'--module-path', configurations.compileClasspath.asPath, // Set module path to modular dependencies
	]
	classpath = files() // Clear the default classpath to avoid mixing with module path
}

task compileFakeModLauncher(type: JavaCompile) {
	source = fileTree('src/fake/modlauncher/')
	destinationDir = file("$buildDir/classes/fake/modlauncher")
	classpath = files() // No classpath needed since this is a fake module
	options.compilerArgs = ['--module-path', configurations.compileOnlyResolvable.asPath]
}

task compileFakeModLoader(type: JavaCompile) {
	source = fileTree('src/fake/modloader/')
	destinationDir = file("$buildDir/classes/fake/modloader")
	classpath = files() // No classpath needed since this is a fake module
	options.compilerArgs = ['--module-path', configurations.compileOnlyResolvable.asPath]
}

task compileFakeLog4j(type: JavaCompile) {
	source = fileTree('src/fake/log4j/')
	destinationDir = file("$buildDir/classes/fake/log4j")
	classpath = files() // No classpath needed for fake module
	options.compilerArgs = ['--module-path', configurations.compileOnlyResolvable.asPath]
}

task jarFakeModLauncher(type: Jar) {
	dependsOn compileFakeModLauncher
	archiveFileName.set('modlauncher.jar')
	destinationDirectory.set(file("$buildDir/fake"))
	from("$buildDir/classes/fake/modlauncher")
}

task jarFakeModLoader(type: Jar) {
	dependsOn compileFakeModLoader
	archiveFileName.set('modloader.jar')
	destinationDirectory.set(file("$buildDir/fake"))
	from("$buildDir/classes/fake/modloader")
}

task jarFakeLog4j(type: Jar) {
	dependsOn compileFakeLog4j
	archiveFileName.set('log4j.jar')
	destinationDirectory.set(file("$buildDir/fake"))
	from("$buildDir/classes/fake/log4j")
}

tasks.compileJava {
	dependsOn jarFakeModLauncher, jarFakeModLoader, jarFakeLog4j
	doFirst {
		def fakeModulesJarPath = "$buildDir/fake/modlauncher.jar:$buildDir/fake/modloader.jar:$buildDir/fake/log4j.jar"
		def modulePath = "$fakeModulesJarPath:${configurations.compileOnlyResolvable.asPath}:${configurations.implementationResolvable.asPath}"
		options.compilerArgs += ['--module-path', modulePath]
	}
}


jar {
	manifest {
		attributes(
			'Main-Class': 'net.fabricmc.loader.impl.launch.knot.KnotClient',
			'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' '),
			'Specification-Version': 8.0,
			'Multi-Release': 'true'
		)
	}
}

task sourcesJar(type: Jar) {
	archiveClassifier.set("sources")
	from sourceSets.main.allSource
	from(fileTree('src/fake')) { // Include the fake module files into the 'fake' subdirectory
		into 'fake'
	}
}

artifacts {
	archives jar
	archives sourcesJar
}

publishing {
	publications {
		mavenJava(MavenPublication) {
			from components.java
			artifact sourcesJar
		}
	}
}